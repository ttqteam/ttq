package ttq.pipeline

import ttq.common._
import ttq.parser._
import ttq.lf._
import ttq.tokenizer._

object TheGrammar extends Grammar[Token, Option[Token]] {
  case object S extends NonTerminal
  case object FACT extends NonTerminal
  case object AGG extends NonTerminal
  case object GROUP extends NonTerminal
  case object FILTER extends NonTerminal
  case object OP extends NonTerminal
  case object BEXPR extends NonTerminal
  case object TERM extends NonTerminal
  case object FACTOR extends NonTerminal

  case object Facts extends Terminal
  case object Aggregate extends Terminal
  case object Dimension extends Terminal
  case object NumVal extends Terminal
  case object DateVal extends Terminal
  case object StrVal extends Terminal
  case class Keyword(s:String) extends Terminal

  private val BY = Keyword(Keywords.by)
  private val OR = Keyword(Keywords.or)
  private val AND = Keyword(Keywords.and)
  private val WHERE = Keyword(Keywords.where)

  // terminal placeholders - represent to-be-generated expressions/strings (to be replaced with real expressions by validator)
  case object FactorPlaceholder extends Terminal

  override val start = S

  override val rules = List(
    // todo: handle placeholders everywhere (see Some below - it must be None if palceholder generated by grammar)
    Rule(S,     List(FACT),               xs => FactsQuery(xs(0).asInstanceOf[FactsExpr], None)),
    Rule(S,     List(FACT, FILTER),       xs => FactsQuery(xs(0).asInstanceOf[FactsExpr], Some(xs(1).asInstanceOf[FilterExpr]))),
    Rule(S,     List(AGG),                xs => AggregateQuery(xs(0).asInstanceOf[AggregateExpr], None, None)),
    Rule(S,     List(AGG, GROUP),         xs => AggregateQuery(xs(0).asInstanceOf[AggregateExpr], Some(xs(1).asInstanceOf[GroupByExpr]), None)),
    Rule(S,     List(AGG, GROUP, FILTER), xs => AggregateQuery(xs(0).asInstanceOf[AggregateExpr], Some(xs(1).asInstanceOf[GroupByExpr]), Some(xs(2).asInstanceOf[FilterExpr]))),
    Rule(S,     List(AGG, FILTER, GROUP), xs => AggregateQuery(xs(0).asInstanceOf[AggregateExpr], Some(xs(2).asInstanceOf[GroupByExpr]), Some(xs(1).asInstanceOf[FilterExpr]))),
    Rule(S,     List(AGG, FILTER),        xs => AggregateQuery(xs(0).asInstanceOf[AggregateExpr], None,                                  Some(xs(1).asInstanceOf[FilterExpr]))),
    Rule(S,     List(FILTER, AGG),        xs => AggregateQuery(xs(1).asInstanceOf[AggregateExpr], None,                                  Some(xs(0).asInstanceOf[FilterExpr]))),
    Rule(S,     List(FILTER, AGG, GROUP), xs => AggregateQuery(xs(1).asInstanceOf[AggregateExpr], Some(xs(2).asInstanceOf[GroupByExpr]), Some(xs(0).asInstanceOf[FilterExpr]))),

    Rule(FACT,  List(Facts),              xs => FactsExpr(xs(0).asInstanceOf[Option[FactsToken]].map(_.ref))),
    Rule(AGG,   List(Aggregate),          xs => UserAggregateExpr(xs(0).asInstanceOf[Option[AggregateToken]].map(_.ref))),
    Rule(GROUP, List(BY, Dimension),      xs => GroupByDimensionExpr(xs(1).asInstanceOf[Option[DimensionToken]].map(_.ref))),
    Rule(FILTER,List(WHERE, BEXPR),       xs => xs(1)),

    Rule(BEXPR, List(TERM),           xs => xs(0)),
    Rule(BEXPR, List(TERM, OR, BEXPR), xs => OrExpr(xs(0).asInstanceOf[FilterExpr], xs(2).asInstanceOf[FilterExpr])),

    Rule(TERM, List(FACTOR),            xs => xs(0)),
    Rule(TERM, List(FACTOR, AND, TERM), xs => AndExpr(xs(0).asInstanceOf[FilterExpr], xs(2).asInstanceOf[FilterExpr])),
    // todo parens

    // rule to generate factor placeholder expressions
//    Rule(FACTOR, List(FactorPlaceholder), xs => FactorExpr),
    Rule(FACTOR,  List(Dimension, OP, NumVal), xs => DimensionOpNumberExpr(
      xs(0).asInstanceOf[Option[DimensionToken]].map(_.ref),
      xs(1).asInstanceOf[Option[Operation]],
      xs(2).asInstanceOf[Option[NumberToken]].map(n => NumberEntityRef(n.value)),
    )),
    Rule(FACTOR,  List(Dimension, Keyword(Keywords.gt), DateVal), xs => FilterByDateExpr(
      xs(0).asInstanceOf[Option[DimensionToken]].map(_.ref),
      xs(2).asInstanceOf[Option[DateToken]].map(t => DateEntityRef(t.value)),
    )),
    Rule(FACTOR,  List(Dimension, Keyword(Keywords.eq), StrVal), xs => DimensionEqualsEntityExpr(
      xs(0).asInstanceOf[Option[DimensionToken]].map(_.ref),
      xs(2).asInstanceOf[Option[StringEntityToken]].map(v => StringEntityRef(v.dimension, v.name)),
    )),
    Rule(OP, List(Keyword(Keywords.eq)), _ => Some(EQ)),
    Rule(OP, List(Keyword(Keywords.gt)), _ => Some(GT)),
    Rule(OP, List(Keyword(Keywords.lt)), _ => Some(LT)),
    Rule(FACTOR, List(Dimension), xs => BooleanDimensionExpr(xs(0).asInstanceOf[Option[DimensionToken]].map(_.ref))),
    Rule(FACTOR, List(Dimension, Keyword(Keywords.lastMonth)), xs => LastMonthExpr(xs(0).asInstanceOf[Option[DimensionToken]].map(_.ref))),
    Rule(FACTOR, List(Keyword(Keywords.lastMonth)), xs => LastMonthExpr(None))
  )

  override def tokenToTerminal(token: Token): Terminal = token match
  {
    case _:FactsToken        => Facts
    case _:AggregateToken    => Aggregate
    case _:DimensionToken    => Dimension
    case _:NumberToken       => NumVal
    case _:DateToken         => DateVal
    case _:StringEntityToken => StrVal
    case KeywordToken(name)  => Keyword(name)
    case _:WordToken         => throw new IllegalArgumentException("WordToken must not be present to parser")
  }

  override def terminalToLeaf(symbol: Terminal): Option[Token] = symbol match {
    // we can only guess token for keyword terminals (we can't generate, say, proper DimensionToken(ref) - we don't know "ref")
    case Keyword(s) => Some(KeywordToken(s))
    case _ => None
  }

  override def tokenToLeaf(token: Token): Option[Token] = Some(token)

  override def deleteCost(tokenToDelete: Token): Double = 2.0

  override def insertCost(rule:Rule, symbolToInsert: Terminal): Double = symbolToInsert match {
    case Dimension if rule.lhs != GROUP && rule.lhs != FACTOR => 0.0
    case Keyword(Keywords.where) => 0.0
    case Keyword(Keywords.by) => 0.0
    case Keyword(Keywords.eq) => 0.0
    case Keyword(Keywords.gt) => 0.0
    case Keyword(Keywords.lt) => 0.0
    case _ => 1
  }

  override def replaceCost(rule: Rule, tokenToDelete: Token, symbolToInsert: Terminal): Double = {
    deleteCost(tokenToDelete) + insertCost(rule, symbolToInsert)
  }
}


